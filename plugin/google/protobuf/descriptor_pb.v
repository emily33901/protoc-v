// Generated by vproto - Do not modify
module protobuf

import emily33901.vproto

pub struct ProtobufFileDescriptorSet {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	file           []ProtobufFileDescriptorProto
}

pub fn new_protobuffiledescriptorset() ProtobufFileDescriptorSet {
	return ProtobufFileDescriptorSet{}
}

pub fn (o &ProtobufFileDescriptorSet) pack() []byte {
	mut res := []byte{}
	for _, x in o.file {
		res << pack_protobuffiledescriptorproto(x, 1)
	}
	return res
}

pub fn protobuffiledescriptorset_unpack(buf []byte) ?ProtobufFileDescriptorSet {
	mut res := ProtobufFileDescriptorSet{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := unpack_protobuffiledescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.file << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobuffiledescriptorset(o ProtobufFileDescriptorSet, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobuffiledescriptorset(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFileDescriptorSet) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobuffiledescriptorset_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufFileDescriptorProto {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	name                 string
	has_name             bool
	package              string
	has_package          bool
	dependency           []string
	message_type         []ProtobufDescriptorProto
	enum_type            []ProtobufEnumDescriptorProto
	service              []ProtobufServiceDescriptorProto
	extension            []ProtobufFieldDescriptorProto
	options              ProtobufFileOptions
	has_options          bool
	source_code_info     ProtobufSourceCodeInfo
	has_source_code_info bool
}

pub fn new_protobuffiledescriptorproto() ProtobufFileDescriptorProto {
	return ProtobufFileDescriptorProto{}
}

pub fn (o &ProtobufFileDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_package {
		res << vproto.pack_string_field(o.package, 2)
	}
	for _, x in o.dependency {
		res << vproto.pack_string_field(x, 3)
	}
	for _, x in o.message_type {
		res << pack_protobufdescriptorproto(x, 4)
	}
	for _, x in o.enum_type {
		res << pack_protobufenumdescriptorproto(x, 5)
	}
	for _, x in o.service {
		res << pack_protobufservicedescriptorproto(x, 6)
	}
	for _, x in o.extension {
		res << pack_protobuffielddescriptorproto(x, 7)
	}
	if o.has_options {
		res << pack_protobuffileoptions(o.options, 8)
	}
	if o.has_source_code_info {
		res << pack_protobufsourcecodeinfo(o.source_code_info, 9)
	}
	return res
}

pub fn protobuffiledescriptorproto_unpack(buf []byte) ?ProtobufFileDescriptorProto {
	mut res := ProtobufFileDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				res.has_package = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.package = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.dependency << v
				i = ii
			}
			4 {
				ii, v := unpack_protobufdescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.message_type << v
				i = ii
			}
			5 {
				ii, v := unpack_protobufenumdescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.enum_type << v
				i = ii
			}
			6 {
				ii, v := unpack_protobufservicedescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.service << v
				i = ii
			}
			7 {
				ii, v := unpack_protobuffielddescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.extension << v
				i = ii
			}
			8 {
				res.has_options = true
				ii, v := unpack_protobuffileoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			9 {
				res.has_source_code_info = true
				ii, v := unpack_protobufsourcecodeinfo(cur_buf, tag_wiretype.wire_type)
				res.source_code_info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobuffiledescriptorproto(o ProtobufFileDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobuffiledescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFileDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobuffiledescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufDescriptorProtoExtensionRange {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	start          int
	has_start      bool
	end            int
	has_end        bool
}

pub fn new_protobufdescriptorprotoextensionrange() ProtobufDescriptorProtoExtensionRange {
	return ProtobufDescriptorProtoExtensionRange{}
}

pub fn (o &ProtobufDescriptorProtoExtensionRange) pack() []byte {
	mut res := []byte{}
	if o.has_start {
		res << vproto.pack_int32_field(o.start, 1)
	}
	if o.has_end {
		res << vproto.pack_int32_field(o.end, 2)
	}
	return res
}

pub fn protobufdescriptorprotoextensionrange_unpack(buf []byte) ?ProtobufDescriptorProtoExtensionRange {
	mut res := ProtobufDescriptorProtoExtensionRange{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_start = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.start = v
				i = ii
			}
			2 {
				res.has_end = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.end = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufdescriptorprotoextensionrange(o ProtobufDescriptorProtoExtensionRange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufdescriptorprotoextensionrange(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufDescriptorProtoExtensionRange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufdescriptorprotoextensionrange_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufDescriptorProto {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	name            string
	has_name        bool
	field           []ProtobufFieldDescriptorProto
	extension       []ProtobufFieldDescriptorProto
	nested_type     []ProtobufDescriptorProto
	enum_type       []ProtobufEnumDescriptorProto
	extension_range []ProtobufDescriptorProtoExtensionRange
	options         ProtobufMessageOptions
	has_options     bool
}

pub fn new_protobufdescriptorproto() ProtobufDescriptorProto {
	return ProtobufDescriptorProto{}
}

pub fn (o &ProtobufDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	for _, x in o.field {
		res << pack_protobuffielddescriptorproto(x, 2)
	}
	for _, x in o.extension {
		res << pack_protobuffielddescriptorproto(x, 6)
	}
	for _, x in o.nested_type {
		res << pack_protobufdescriptorproto(x, 3)
	}
	for _, x in o.enum_type {
		res << pack_protobufenumdescriptorproto(x, 4)
	}
	for _, x in o.extension_range {
		res << pack_protobufdescriptorprotoextensionrange(x, 5)
	}
	if o.has_options {
		res << pack_protobufmessageoptions(o.options, 7)
	}
	return res
}

pub fn protobufdescriptorproto_unpack(buf []byte) ?ProtobufDescriptorProto {
	mut res := ProtobufDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				ii, v := unpack_protobuffielddescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.field << v
				i = ii
			}
			6 {
				ii, v := unpack_protobuffielddescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.extension << v
				i = ii
			}
			3 {
				ii, v := unpack_protobufdescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.nested_type << v
				i = ii
			}
			4 {
				ii, v := unpack_protobufenumdescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.enum_type << v
				i = ii
			}
			5 {
				ii, v := unpack_protobufdescriptorprotoextensionrange(cur_buf, tag_wiretype.wire_type)
				res.extension_range << v
				i = ii
			}
			7 {
				res.has_options = true
				ii, v := unpack_protobufmessageoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufdescriptorproto(o ProtobufDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufdescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufdescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

enum ProtobufFieldDescriptorProtoType {
	type_double = 1
	type_float = 2
	type_int64 = 3
	type_uint64 = 4
	type_int32 = 5
	type_fixed64 = 6
	type_fixed32 = 7
	type_bool = 8
	type_string = 9
	type_group = 10
	type_message = 11
	type_bytes = 12
	type_uint32 = 13
	type_enum = 14
	type_sfixed32 = 15
	type_sfixed64 = 16
	type_sint32 = 17
	type_sint64 = 18
}

fn pack_protobuffielddescriptorprototype(e ProtobufFieldDescriptorProtoType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

fn unpack_protobuffielddescriptorprototype(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFieldDescriptorProtoType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, ProtobufFieldDescriptorProtoType(v)
}

enum ProtobufFieldDescriptorProtoLabel {
	label_optional = 1
	label_required = 2
	label_repeated = 3
}

fn pack_protobuffielddescriptorprotolabel(e ProtobufFieldDescriptorProtoLabel, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

fn unpack_protobuffielddescriptorprotolabel(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFieldDescriptorProtoLabel) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, ProtobufFieldDescriptorProtoLabel(v)
}

pub struct ProtobufFieldDescriptorProto {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	name              string
	has_name          bool
	number            int
	has_number        bool
	label             ProtobufFieldDescriptorProtoLabel
	has_label         bool
	type_             ProtobufFieldDescriptorProtoType
	has_type_         bool
	type_name         string
	has_type_name     bool
	extendee          string
	has_extendee      bool
	default_value     string
	has_default_value bool
	options           ProtobufFieldOptions
	has_options       bool
}

pub fn new_protobuffielddescriptorproto() ProtobufFieldDescriptorProto {
	return ProtobufFieldDescriptorProto{}
}

pub fn (o &ProtobufFieldDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_number {
		res << vproto.pack_int32_field(o.number, 3)
	}
	if o.has_label {
		res << pack_protobuffielddescriptorprotolabel(o.label, 4)
	}
	if o.has_type_ {
		res << pack_protobuffielddescriptorprototype(o.type_, 5)
	}
	if o.has_type_name {
		res << vproto.pack_string_field(o.type_name, 6)
	}
	if o.has_extendee {
		res << vproto.pack_string_field(o.extendee, 2)
	}
	if o.has_default_value {
		res << vproto.pack_string_field(o.default_value, 7)
	}
	if o.has_options {
		res << pack_protobuffieldoptions(o.options, 8)
	}
	return res
}

pub fn protobuffielddescriptorproto_unpack(buf []byte) ?ProtobufFieldDescriptorProto {
	mut res := ProtobufFieldDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			3 {
				res.has_number = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.number = v
				i = ii
			}
			4 {
				res.has_label = true
				ii, v := unpack_protobuffielddescriptorprotolabel(cur_buf, tag_wiretype.wire_type)
				res.label = v
				i = ii
			}
			5 {
				res.has_type_ = true
				ii, v := unpack_protobuffielddescriptorprototype(cur_buf, tag_wiretype.wire_type)
				res.type_ = v
				i = ii
			}
			6 {
				res.has_type_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.type_name = v
				i = ii
			}
			2 {
				res.has_extendee = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.extendee = v
				i = ii
			}
			7 {
				res.has_default_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.default_value = v
				i = ii
			}
			8 {
				res.has_options = true
				ii, v := unpack_protobuffieldoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobuffielddescriptorproto(o ProtobufFieldDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobuffielddescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFieldDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobuffielddescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufEnumDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          []ProtobufEnumValueDescriptorProto
	options        ProtobufEnumOptions
	has_options    bool
}

pub fn new_protobufenumdescriptorproto() ProtobufEnumDescriptorProto {
	return ProtobufEnumDescriptorProto{}
}

pub fn (o &ProtobufEnumDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	for _, x in o.value {
		res << pack_protobufenumvaluedescriptorproto(x, 2)
	}
	if o.has_options {
		res << pack_protobufenumoptions(o.options, 3)
	}
	return res
}

pub fn protobufenumdescriptorproto_unpack(buf []byte) ?ProtobufEnumDescriptorProto {
	mut res := ProtobufEnumDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				ii, v := unpack_protobufenumvaluedescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.value << v
				i = ii
			}
			3 {
				res.has_options = true
				ii, v := unpack_protobufenumoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufenumdescriptorproto(o ProtobufEnumDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufenumdescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufEnumDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufenumdescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufEnumValueDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	number         int
	has_number     bool
	options        ProtobufEnumValueOptions
	has_options    bool
}

pub fn new_protobufenumvaluedescriptorproto() ProtobufEnumValueDescriptorProto {
	return ProtobufEnumValueDescriptorProto{}
}

pub fn (o &ProtobufEnumValueDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_number {
		res << vproto.pack_int32_field(o.number, 2)
	}
	if o.has_options {
		res << pack_protobufenumvalueoptions(o.options, 3)
	}
	return res
}

pub fn protobufenumvaluedescriptorproto_unpack(buf []byte) ?ProtobufEnumValueDescriptorProto {
	mut res := ProtobufEnumValueDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				res.has_number = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.number = v
				i = ii
			}
			3 {
				res.has_options = true
				ii, v := unpack_protobufenumvalueoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufenumvaluedescriptorproto(o ProtobufEnumValueDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufenumvaluedescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufEnumValueDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufenumvaluedescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufServiceDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	method         []ProtobufMethodDescriptorProto
	options        ProtobufServiceOptions
	has_options    bool
}

pub fn new_protobufservicedescriptorproto() ProtobufServiceDescriptorProto {
	return ProtobufServiceDescriptorProto{}
}

pub fn (o &ProtobufServiceDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	for _, x in o.method {
		res << pack_protobufmethoddescriptorproto(x, 2)
	}
	if o.has_options {
		res << pack_protobufserviceoptions(o.options, 3)
	}
	return res
}

pub fn protobufservicedescriptorproto_unpack(buf []byte) ?ProtobufServiceDescriptorProto {
	mut res := ProtobufServiceDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				ii, v := unpack_protobufmethoddescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.method << v
				i = ii
			}
			3 {
				res.has_options = true
				ii, v := unpack_protobufserviceoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufservicedescriptorproto(o ProtobufServiceDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufservicedescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufServiceDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufservicedescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufMethodDescriptorProto {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	name            string
	has_name        bool
	input_type      string
	has_input_type  bool
	output_type     string
	has_output_type bool
	options         ProtobufMethodOptions
	has_options     bool
}

pub fn new_protobufmethoddescriptorproto() ProtobufMethodDescriptorProto {
	return ProtobufMethodDescriptorProto{}
}

pub fn (o &ProtobufMethodDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_input_type {
		res << vproto.pack_string_field(o.input_type, 2)
	}
	if o.has_output_type {
		res << vproto.pack_string_field(o.output_type, 3)
	}
	if o.has_options {
		res << pack_protobufmethodoptions(o.options, 4)
	}
	return res
}

pub fn protobufmethoddescriptorproto_unpack(buf []byte) ?ProtobufMethodDescriptorProto {
	mut res := ProtobufMethodDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				res.has_input_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.input_type = v
				i = ii
			}
			3 {
				res.has_output_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.output_type = v
				i = ii
			}
			4 {
				res.has_options = true
				ii, v := unpack_protobufmethodoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufmethoddescriptorproto(o ProtobufMethodDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufmethoddescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufMethodDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufmethoddescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

enum ProtobufFileOptionsOptimizeMode {
	speed = 1
	code_size = 2
	lite_runtime = 3
}

fn pack_protobuffileoptionsoptimizemode(e ProtobufFileOptionsOptimizeMode, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

fn unpack_protobuffileoptionsoptimizemode(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFileOptionsOptimizeMode) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, ProtobufFileOptionsOptimizeMode(v)
}

pub struct ProtobufFileOptions {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	java_package                      string
	has_java_package                  bool
	java_outer_classname              string
	has_java_outer_classname          bool
	java_multiple_files               bool
	has_java_multiple_files           bool
	java_generate_equals_and_hash     bool
	has_java_generate_equals_and_hash bool
	optimize_for                      ProtobufFileOptionsOptimizeMode
	has_optimize_for                  bool
	cc_generic_services               bool
	has_cc_generic_services           bool
	java_generic_services             bool
	has_java_generic_services         bool
	py_generic_services               bool
	has_py_generic_services           bool
	uninterpreted_option              []ProtobufUninterpretedOption
}

pub fn new_protobuffileoptions() ProtobufFileOptions {
	return ProtobufFileOptions{}
}

pub fn (o &ProtobufFileOptions) pack() []byte {
	mut res := []byte{}
	if o.has_java_package {
		res << vproto.pack_string_field(o.java_package, 1)
	}
	if o.has_java_outer_classname {
		res << vproto.pack_string_field(o.java_outer_classname, 8)
	}
	if o.has_java_multiple_files {
		res << vproto.pack_bool_field(o.java_multiple_files, 10)
	}
	if o.has_java_generate_equals_and_hash {
		res << vproto.pack_bool_field(o.java_generate_equals_and_hash, 20)
	}
	if o.has_optimize_for {
		res << pack_protobuffileoptionsoptimizemode(o.optimize_for, 9)
	}
	if o.has_cc_generic_services {
		res << vproto.pack_bool_field(o.cc_generic_services, 16)
	}
	if o.has_java_generic_services {
		res << vproto.pack_bool_field(o.java_generic_services, 17)
	}
	if o.has_py_generic_services {
		res << vproto.pack_bool_field(o.py_generic_services, 18)
	}
	for _, x in o.uninterpreted_option {
		res << pack_protobufuninterpretedoption(x, 999)
	}
	return res
}

pub fn protobuffileoptions_unpack(buf []byte) ?ProtobufFileOptions {
	mut res := ProtobufFileOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_java_package = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.java_package = v
				i = ii
			}
			8 {
				res.has_java_outer_classname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.java_outer_classname = v
				i = ii
			}
			10 {
				res.has_java_multiple_files = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.java_multiple_files = v
				i = ii
			}
			20 {
				res.has_java_generate_equals_and_hash = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.java_generate_equals_and_hash = v
				i = ii
			}
			9 {
				res.has_optimize_for = true
				ii, v := unpack_protobuffileoptionsoptimizemode(cur_buf, tag_wiretype.wire_type)
				res.optimize_for = v
				i = ii
			}
			16 {
				res.has_cc_generic_services = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.cc_generic_services = v
				i = ii
			}
			17 {
				res.has_java_generic_services = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.java_generic_services = v
				i = ii
			}
			18 {
				res.has_py_generic_services = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.py_generic_services = v
				i = ii
			}
			999 {
				ii, v := unpack_protobufuninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobuffileoptions(o ProtobufFileOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobuffileoptions(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFileOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobuffileoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufMessageOptions {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	message_set_wire_format             bool
	has_message_set_wire_format         bool
	no_standard_descriptor_accessor     bool
	has_no_standard_descriptor_accessor bool
	uninterpreted_option                []ProtobufUninterpretedOption
}

pub fn new_protobufmessageoptions() ProtobufMessageOptions {
	return ProtobufMessageOptions{}
}

pub fn (o &ProtobufMessageOptions) pack() []byte {
	mut res := []byte{}
	if o.has_message_set_wire_format {
		res << vproto.pack_bool_field(o.message_set_wire_format, 1)
	}
	if o.has_no_standard_descriptor_accessor {
		res << vproto.pack_bool_field(o.no_standard_descriptor_accessor, 2)
	}
	for _, x in o.uninterpreted_option {
		res << pack_protobufuninterpretedoption(x, 999)
	}
	return res
}

pub fn protobufmessageoptions_unpack(buf []byte) ?ProtobufMessageOptions {
	mut res := ProtobufMessageOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_message_set_wire_format = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.message_set_wire_format = v
				i = ii
			}
			2 {
				res.has_no_standard_descriptor_accessor = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.no_standard_descriptor_accessor = v
				i = ii
			}
			999 {
				ii, v := unpack_protobufuninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufmessageoptions(o ProtobufMessageOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufmessageoptions(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufMessageOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufmessageoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

enum ProtobufFieldOptionsCType {
	string = 0
	cord = 1
	string_piece = 2
}

fn pack_protobuffieldoptionsctype(e ProtobufFieldOptionsCType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

fn unpack_protobuffieldoptionsctype(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFieldOptionsCType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, ProtobufFieldOptionsCType(v)
}

pub struct ProtobufFieldOptions {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	ctype                    ProtobufFieldOptionsCType
	has_ctype                bool
	packed                   bool
	has_packed               bool
	deprecated               bool
	has_deprecated           bool
	experimental_map_key     string
	has_experimental_map_key bool
	uninterpreted_option     []ProtobufUninterpretedOption
}

pub fn new_protobuffieldoptions() ProtobufFieldOptions {
	return ProtobufFieldOptions{}
}

pub fn (o &ProtobufFieldOptions) pack() []byte {
	mut res := []byte{}
	if o.has_ctype {
		res << pack_protobuffieldoptionsctype(o.ctype, 1)
	}
	if o.has_packed {
		res << vproto.pack_bool_field(o.packed, 2)
	}
	if o.has_deprecated {
		res << vproto.pack_bool_field(o.deprecated, 3)
	}
	if o.has_experimental_map_key {
		res << vproto.pack_string_field(o.experimental_map_key, 9)
	}
	for _, x in o.uninterpreted_option {
		res << pack_protobufuninterpretedoption(x, 999)
	}
	return res
}

pub fn protobuffieldoptions_unpack(buf []byte) ?ProtobufFieldOptions {
	mut res := ProtobufFieldOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ctype = true
				ii, v := unpack_protobuffieldoptionsctype(cur_buf, tag_wiretype.wire_type)
				res.ctype = v
				i = ii
			}
			2 {
				res.has_packed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.packed = v
				i = ii
			}
			3 {
				res.has_deprecated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.deprecated = v
				i = ii
			}
			9 {
				res.has_experimental_map_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.experimental_map_key = v
				i = ii
			}
			999 {
				ii, v := unpack_protobufuninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobuffieldoptions(o ProtobufFieldOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobuffieldoptions(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufFieldOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobuffieldoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufEnumOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	uninterpreted_option []ProtobufUninterpretedOption
}

pub fn new_protobufenumoptions() ProtobufEnumOptions {
	return ProtobufEnumOptions{}
}

pub fn (o &ProtobufEnumOptions) pack() []byte {
	mut res := []byte{}
	for _, x in o.uninterpreted_option {
		res << pack_protobufuninterpretedoption(x, 999)
	}
	return res
}

pub fn protobufenumoptions_unpack(buf []byte) ?ProtobufEnumOptions {
	mut res := ProtobufEnumOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			999 {
				ii, v := unpack_protobufuninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufenumoptions(o ProtobufEnumOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufenumoptions(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufEnumOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufenumoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufEnumValueOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	uninterpreted_option []ProtobufUninterpretedOption
}

pub fn new_protobufenumvalueoptions() ProtobufEnumValueOptions {
	return ProtobufEnumValueOptions{}
}

pub fn (o &ProtobufEnumValueOptions) pack() []byte {
	mut res := []byte{}
	for _, x in o.uninterpreted_option {
		res << pack_protobufuninterpretedoption(x, 999)
	}
	return res
}

pub fn protobufenumvalueoptions_unpack(buf []byte) ?ProtobufEnumValueOptions {
	mut res := ProtobufEnumValueOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			999 {
				ii, v := unpack_protobufuninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufenumvalueoptions(o ProtobufEnumValueOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufenumvalueoptions(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufEnumValueOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufenumvalueoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufServiceOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	uninterpreted_option []ProtobufUninterpretedOption
}

pub fn new_protobufserviceoptions() ProtobufServiceOptions {
	return ProtobufServiceOptions{}
}

pub fn (o &ProtobufServiceOptions) pack() []byte {
	mut res := []byte{}
	for _, x in o.uninterpreted_option {
		res << pack_protobufuninterpretedoption(x, 999)
	}
	return res
}

pub fn protobufserviceoptions_unpack(buf []byte) ?ProtobufServiceOptions {
	mut res := ProtobufServiceOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			999 {
				ii, v := unpack_protobufuninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufserviceoptions(o ProtobufServiceOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufserviceoptions(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufServiceOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufserviceoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufMethodOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	uninterpreted_option []ProtobufUninterpretedOption
}

pub fn new_protobufmethodoptions() ProtobufMethodOptions {
	return ProtobufMethodOptions{}
}

pub fn (o &ProtobufMethodOptions) pack() []byte {
	mut res := []byte{}
	for _, x in o.uninterpreted_option {
		res << pack_protobufuninterpretedoption(x, 999)
	}
	return res
}

pub fn protobufmethodoptions_unpack(buf []byte) ?ProtobufMethodOptions {
	mut res := ProtobufMethodOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			999 {
				ii, v := unpack_protobufuninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufmethodoptions(o ProtobufMethodOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufmethodoptions(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufMethodOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufmethodoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufUninterpretedOptionNamePart {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name_part      string
	is_extension   bool
}

pub fn new_protobufuninterpretedoptionnamepart() ProtobufUninterpretedOptionNamePart {
	return ProtobufUninterpretedOptionNamePart{}
}

pub fn (o &ProtobufUninterpretedOptionNamePart) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_string_field(o.name_part, 1)
	res << vproto.pack_bool_field(o.is_extension, 2)
	return res
}

pub fn protobufuninterpretedoptionnamepart_unpack(buf []byte) ?ProtobufUninterpretedOptionNamePart {
	mut res := ProtobufUninterpretedOptionNamePart{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name_part = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.is_extension = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufuninterpretedoptionnamepart(o ProtobufUninterpretedOptionNamePart, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufuninterpretedoptionnamepart(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufUninterpretedOptionNamePart) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufuninterpretedoptionnamepart_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufUninterpretedOption {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	name                   []ProtobufUninterpretedOptionNamePart
	identifier_value       string
	has_identifier_value   bool
	positive_int_value     u64
	has_positive_int_value bool
	negative_int_value     i64
	has_negative_int_value bool
	double_value           f64
	has_double_value       bool
	string_value           []byte
	has_string_value       bool
	aggregate_value        string
	has_aggregate_value    bool
}

pub fn new_protobufuninterpretedoption() ProtobufUninterpretedOption {
	return ProtobufUninterpretedOption{}
}

pub fn (o &ProtobufUninterpretedOption) pack() []byte {
	mut res := []byte{}
	for _, x in o.name {
		res << pack_protobufuninterpretedoptionnamepart(x, 2)
	}
	if o.has_identifier_value {
		res << vproto.pack_string_field(o.identifier_value, 3)
	}
	if o.has_positive_int_value {
		res << vproto.pack_uint64_field(o.positive_int_value, 4)
	}
	if o.has_negative_int_value {
		res << vproto.pack_int64_field(o.negative_int_value, 5)
	}
	if o.has_double_value {
		res << vproto.pack_double_field(o.double_value, 6)
	}
	if o.has_string_value {
		res << vproto.pack_bytes_field(o.string_value, 7)
	}
	if o.has_aggregate_value {
		res << vproto.pack_string_field(o.aggregate_value, 8)
	}
	return res
}

pub fn protobufuninterpretedoption_unpack(buf []byte) ?ProtobufUninterpretedOption {
	mut res := ProtobufUninterpretedOption{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				ii, v := unpack_protobufuninterpretedoptionnamepart(cur_buf, tag_wiretype.wire_type)
				res.name << v
				i = ii
			}
			3 {
				res.has_identifier_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.identifier_value = v
				i = ii
			}
			4 {
				res.has_positive_int_value = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)
				res.positive_int_value = v
				i = ii
			}
			5 {
				res.has_negative_int_value = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)
				res.negative_int_value = v
				i = ii
			}
			6 {
				res.has_double_value = true
				ii, v := vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)
				res.double_value = v
				i = ii
			}
			7 {
				res.has_string_value = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)
				res.string_value = v
				i = ii
			}
			8 {
				res.has_aggregate_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.aggregate_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufuninterpretedoption(o ProtobufUninterpretedOption, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufuninterpretedoption(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufUninterpretedOption) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufuninterpretedoption_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufSourceCodeInfoLocation {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	path           []int
	span           []int
}

pub fn new_protobufsourcecodeinfolocation() ProtobufSourceCodeInfoLocation {
	return ProtobufSourceCodeInfoLocation{}
}

pub fn (o &ProtobufSourceCodeInfoLocation) pack() []byte {
	mut res := []byte{}
	for _, x in o.path {
		res << vproto.pack_int32_field(x, 1)
	}
	for _, x in o.span {
		res << vproto.pack_int32_field(x, 2)
	}
	return res
}

pub fn protobufsourcecodeinfolocation_unpack(buf []byte) ?ProtobufSourceCodeInfoLocation {
	mut res := ProtobufSourceCodeInfoLocation{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.path << v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.span << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufsourcecodeinfolocation(o ProtobufSourceCodeInfoLocation, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufsourcecodeinfolocation(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufSourceCodeInfoLocation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufsourcecodeinfolocation_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ProtobufSourceCodeInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	location       []ProtobufSourceCodeInfoLocation
}

pub fn new_protobufsourcecodeinfo() ProtobufSourceCodeInfo {
	return ProtobufSourceCodeInfo{}
}

pub fn (o &ProtobufSourceCodeInfo) pack() []byte {
	mut res := []byte{}
	for _, x in o.location {
		res << pack_protobufsourcecodeinfolocation(x, 1)
	}
	return res
}

pub fn protobufsourcecodeinfo_unpack(buf []byte) ?ProtobufSourceCodeInfo {
	mut res := ProtobufSourceCodeInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := unpack_protobufsourcecodeinfolocation(cur_buf, tag_wiretype.wire_type)
				res.location << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_protobufsourcecodeinfo(o ProtobufSourceCodeInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_protobufsourcecodeinfo(buf []byte, tag_wiretype vproto.WireType) (int, ProtobufSourceCodeInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := protobufsourcecodeinfo_unpack(v) or {
		panic('')
	}
	return i, unpacked
}
