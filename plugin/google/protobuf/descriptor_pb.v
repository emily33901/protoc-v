// Generated by vproto - Do not modify
module protobuf

import emily33901.vproto

pub struct FileDescriptorSet {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	file           []FileDescriptorProto
}

pub fn new_filedescriptorset() FileDescriptorSet {
	return FileDescriptorSet{}
}

pub fn (o &FileDescriptorSet) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.file {
		res << pack_filedescriptorproto(x, 1)
	}
	return res
}

pub fn filedescriptorset_unpack(buf []byte) ?FileDescriptorSet {
	mut res := FileDescriptorSet{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := unpack_filedescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.file << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_filedescriptorset(o FileDescriptorSet, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_filedescriptorset(buf []byte, tag_wiretype vproto.WireType) (int, FileDescriptorSet) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := filedescriptorset_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct FileDescriptorProto {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	name                 string
	has_name             bool
	package              string
	has_package          bool
	dependency           []string
	message_type         []DescriptorProto
	enum_type            []EnumDescriptorProto
	service              []ServiceDescriptorProto
	extension            []FieldDescriptorProto
	options              FileOptions
	has_options          bool
	source_code_info     SourceCodeInfo
	has_source_code_info bool
}

pub fn new_filedescriptorproto() FileDescriptorProto {
	return FileDescriptorProto{}
}

pub fn (o &FileDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_package {
		res << vproto.pack_string_field(o.package, 2)
	}
	// [packed=false]
	for _, x in o.dependency {
		res << vproto.pack_string_field(x, 3)
	}
	// [packed=false]
	for _, x in o.message_type {
		res << pack_descriptorproto(x, 4)
	}
	// [packed=false]
	for _, x in o.enum_type {
		res << pack_enumdescriptorproto(x, 5)
	}
	// [packed=false]
	for _, x in o.service {
		res << pack_servicedescriptorproto(x, 6)
	}
	// [packed=false]
	for _, x in o.extension {
		res << pack_fielddescriptorproto(x, 7)
	}
	if o.has_options {
		res << pack_fileoptions(o.options, 8)
	}
	if o.has_source_code_info {
		res << pack_sourcecodeinfo(o.source_code_info, 9)
	}
	return res
}

pub fn filedescriptorproto_unpack(buf []byte) ?FileDescriptorProto {
	mut res := FileDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				res.has_package = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.package = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.dependency << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := unpack_descriptorproto(cur_buf, tag_wiretype.wire_type)
				res.message_type << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := unpack_enumdescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.enum_type << v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := unpack_servicedescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.service << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.extension << v
				i = ii
			}
			8 {
				res.has_options = true
				ii, v := unpack_fileoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			9 {
				res.has_source_code_info = true
				ii, v := unpack_sourcecodeinfo(cur_buf, tag_wiretype.wire_type)
				res.source_code_info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_filedescriptorproto(o FileDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_filedescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, FileDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := filedescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct DescriptorProtoExtensionRange {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	start          int
	has_start      bool
	end            int
	has_end        bool
}

pub fn new_descriptorprotoextensionrange() DescriptorProtoExtensionRange {
	return DescriptorProtoExtensionRange{}
}

pub fn (o &DescriptorProtoExtensionRange) pack() []byte {
	mut res := []byte{}
	if o.has_start {
		res << vproto.pack_int32_field(o.start, 1)
	}
	if o.has_end {
		res << vproto.pack_int32_field(o.end, 2)
	}
	return res
}

pub fn descriptorprotoextensionrange_unpack(buf []byte) ?DescriptorProtoExtensionRange {
	mut res := DescriptorProtoExtensionRange{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_start = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.start = v
				i = ii
			}
			2 {
				res.has_end = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.end = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_descriptorprotoextensionrange(o DescriptorProtoExtensionRange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_descriptorprotoextensionrange(buf []byte, tag_wiretype vproto.WireType) (int, DescriptorProtoExtensionRange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := descriptorprotoextensionrange_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct DescriptorProto {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	name            string
	has_name        bool
	field           []FieldDescriptorProto
	extension       []FieldDescriptorProto
	nested_type     []DescriptorProto
	enum_type       []EnumDescriptorProto
	extension_range []DescriptorProtoExtensionRange
	options         MessageOptions
	has_options     bool
}

pub fn new_descriptorproto() DescriptorProto {
	return DescriptorProto{}
}

pub fn (o &DescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	// [packed=false]
	for _, x in o.field {
		res << pack_fielddescriptorproto(x, 2)
	}
	// [packed=false]
	for _, x in o.extension {
		res << pack_fielddescriptorproto(x, 6)
	}
	// [packed=false]
	for _, x in o.nested_type {
		res << pack_descriptorproto(x, 3)
	}
	// [packed=false]
	for _, x in o.enum_type {
		res << pack_enumdescriptorproto(x, 4)
	}
	// [packed=false]
	for _, x in o.extension_range {
		res << pack_descriptorprotoextensionrange(x, 5)
	}
	if o.has_options {
		res << pack_messageoptions(o.options, 7)
	}
	return res
}

pub fn descriptorproto_unpack(buf []byte) ?DescriptorProto {
	mut res := DescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.field << v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.extension << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := unpack_descriptorproto(cur_buf, tag_wiretype.wire_type)
				res.nested_type << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := unpack_enumdescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.enum_type << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := unpack_descriptorprotoextensionrange(cur_buf, tag_wiretype.wire_type)
				res.extension_range << v
				i = ii
			}
			7 {
				res.has_options = true
				ii, v := unpack_messageoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_descriptorproto(o DescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_descriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, DescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := descriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

enum FieldDescriptorProtoType {
	type_double = 1
	type_float = 2
	type_int64 = 3
	type_uint64 = 4
	type_int32 = 5
	type_fixed64 = 6
	type_fixed32 = 7
	type_bool = 8
	type_string = 9
	type_group = 10
	type_message = 11
	type_bytes = 12
	type_uint32 = 13
	type_enum = 14
	type_sfixed32 = 15
	type_sfixed64 = 16
	type_sint32 = 17
	type_sint64 = 18
}

fn pack_fielddescriptorprototype(e FieldDescriptorProtoType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

fn unpack_fielddescriptorprototype(buf []byte, tag_wiretype vproto.WireType) (int, FieldDescriptorProtoType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, FieldDescriptorProtoType(v)
}

enum FieldDescriptorProtoLabel {
	label_optional = 1
	label_required = 2
	label_repeated = 3
}

fn pack_fielddescriptorprotolabel(e FieldDescriptorProtoLabel, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

fn unpack_fielddescriptorprotolabel(buf []byte, tag_wiretype vproto.WireType) (int, FieldDescriptorProtoLabel) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, FieldDescriptorProtoLabel(v)
}

pub struct FieldDescriptorProto {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	name              string
	has_name          bool
	number            int
	has_number        bool
	label             FieldDescriptorProtoLabel
	has_label         bool
	type_             FieldDescriptorProtoType
	has_type_         bool
	type_name         string
	has_type_name     bool
	extendee          string
	has_extendee      bool
	default_value     string
	has_default_value bool
	options           FieldOptions
	has_options       bool
}

pub fn new_fielddescriptorproto() FieldDescriptorProto {
	return FieldDescriptorProto{}
}

pub fn (o &FieldDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_number {
		res << vproto.pack_int32_field(o.number, 3)
	}
	if o.has_label {
		res << pack_fielddescriptorprotolabel(o.label, 4)
	}
	if o.has_type_ {
		res << pack_fielddescriptorprototype(o.type_, 5)
	}
	if o.has_type_name {
		res << vproto.pack_string_field(o.type_name, 6)
	}
	if o.has_extendee {
		res << vproto.pack_string_field(o.extendee, 2)
	}
	if o.has_default_value {
		res << vproto.pack_string_field(o.default_value, 7)
	}
	if o.has_options {
		res << pack_fieldoptions(o.options, 8)
	}
	return res
}

pub fn fielddescriptorproto_unpack(buf []byte) ?FieldDescriptorProto {
	mut res := FieldDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			3 {
				res.has_number = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.number = v
				i = ii
			}
			4 {
				res.has_label = true
				ii, v := unpack_fielddescriptorprotolabel(cur_buf, tag_wiretype.wire_type)
				res.label = v
				i = ii
			}
			5 {
				res.has_type_ = true
				ii, v := unpack_fielddescriptorprototype(cur_buf, tag_wiretype.wire_type)
				res.type_ = v
				i = ii
			}
			6 {
				res.has_type_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.type_name = v
				i = ii
			}
			2 {
				res.has_extendee = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.extendee = v
				i = ii
			}
			7 {
				res.has_default_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.default_value = v
				i = ii
			}
			8 {
				res.has_options = true
				ii, v := unpack_fieldoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_fielddescriptorproto(o FieldDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_fielddescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, FieldDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := fielddescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct EnumDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          []EnumValueDescriptorProto
	options        EnumOptions
	has_options    bool
}

pub fn new_enumdescriptorproto() EnumDescriptorProto {
	return EnumDescriptorProto{}
}

pub fn (o &EnumDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	// [packed=false]
	for _, x in o.value {
		res << pack_enumvaluedescriptorproto(x, 2)
	}
	if o.has_options {
		res << pack_enumoptions(o.options, 3)
	}
	return res
}

pub fn enumdescriptorproto_unpack(buf []byte) ?EnumDescriptorProto {
	mut res := EnumDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := unpack_enumvaluedescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.value << v
				i = ii
			}
			3 {
				res.has_options = true
				ii, v := unpack_enumoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_enumdescriptorproto(o EnumDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_enumdescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, EnumDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := enumdescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct EnumValueDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	number         int
	has_number     bool
	options        EnumValueOptions
	has_options    bool
}

pub fn new_enumvaluedescriptorproto() EnumValueDescriptorProto {
	return EnumValueDescriptorProto{}
}

pub fn (o &EnumValueDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_number {
		res << vproto.pack_int32_field(o.number, 2)
	}
	if o.has_options {
		res << pack_enumvalueoptions(o.options, 3)
	}
	return res
}

pub fn enumvaluedescriptorproto_unpack(buf []byte) ?EnumValueDescriptorProto {
	mut res := EnumValueDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				res.has_number = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)
				res.number = v
				i = ii
			}
			3 {
				res.has_options = true
				ii, v := unpack_enumvalueoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_enumvaluedescriptorproto(o EnumValueDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_enumvaluedescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, EnumValueDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := enumvaluedescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ServiceDescriptorProto {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	method         []MethodDescriptorProto
	options        ServiceOptions
	has_options    bool
}

pub fn new_servicedescriptorproto() ServiceDescriptorProto {
	return ServiceDescriptorProto{}
}

pub fn (o &ServiceDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	// [packed=false]
	for _, x in o.method {
		res << pack_methoddescriptorproto(x, 2)
	}
	if o.has_options {
		res << pack_serviceoptions(o.options, 3)
	}
	return res
}

pub fn servicedescriptorproto_unpack(buf []byte) ?ServiceDescriptorProto {
	mut res := ServiceDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := unpack_methoddescriptorproto(cur_buf, tag_wiretype.wire_type)
				res.method << v
				i = ii
			}
			3 {
				res.has_options = true
				ii, v := unpack_serviceoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_servicedescriptorproto(o ServiceDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_servicedescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, ServiceDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := servicedescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct MethodDescriptorProto {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	name            string
	has_name        bool
	input_type      string
	has_input_type  bool
	output_type     string
	has_output_type bool
	options         MethodOptions
	has_options     bool
}

pub fn new_methoddescriptorproto() MethodDescriptorProto {
	return MethodDescriptorProto{}
}

pub fn (o &MethodDescriptorProto) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_input_type {
		res << vproto.pack_string_field(o.input_type, 2)
	}
	if o.has_output_type {
		res << vproto.pack_string_field(o.output_type, 3)
	}
	if o.has_options {
		res << pack_methodoptions(o.options, 4)
	}
	return res
}

pub fn methoddescriptorproto_unpack(buf []byte) ?MethodDescriptorProto {
	mut res := MethodDescriptorProto{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name = v
				i = ii
			}
			2 {
				res.has_input_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.input_type = v
				i = ii
			}
			3 {
				res.has_output_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.output_type = v
				i = ii
			}
			4 {
				res.has_options = true
				ii, v := unpack_methodoptions(cur_buf, tag_wiretype.wire_type)
				res.options = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_methoddescriptorproto(o MethodDescriptorProto, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_methoddescriptorproto(buf []byte, tag_wiretype vproto.WireType) (int, MethodDescriptorProto) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := methoddescriptorproto_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

enum FileOptionsOptimizeMode {
	speed = 1
	code_size = 2
	lite_runtime = 3
}

fn pack_fileoptionsoptimizemode(e FileOptionsOptimizeMode, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

fn unpack_fileoptionsoptimizemode(buf []byte, tag_wiretype vproto.WireType) (int, FileOptionsOptimizeMode) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, FileOptionsOptimizeMode(v)
}

pub struct FileOptions {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	java_package                      string
	has_java_package                  bool
	java_outer_classname              string
	has_java_outer_classname          bool
	java_multiple_files               bool
	has_java_multiple_files           bool
	java_generate_equals_and_hash     bool
	has_java_generate_equals_and_hash bool
	optimize_for                      FileOptionsOptimizeMode
	has_optimize_for                  bool
	cc_generic_services               bool
	has_cc_generic_services           bool
	java_generic_services             bool
	has_java_generic_services         bool
	py_generic_services               bool
	has_py_generic_services           bool
	uninterpreted_option              []UninterpretedOption
}

pub fn new_fileoptions() FileOptions {
	return FileOptions{}
}

pub fn (o &FileOptions) pack() []byte {
	mut res := []byte{}
	if o.has_java_package {
		res << vproto.pack_string_field(o.java_package, 1)
	}
	if o.has_java_outer_classname {
		res << vproto.pack_string_field(o.java_outer_classname, 8)
	}
	if o.has_java_multiple_files {
		res << vproto.pack_bool_field(o.java_multiple_files, 10)
	}
	if o.has_java_generate_equals_and_hash {
		res << vproto.pack_bool_field(o.java_generate_equals_and_hash, 20)
	}
	if o.has_optimize_for {
		res << pack_fileoptionsoptimizemode(o.optimize_for, 9)
	}
	if o.has_cc_generic_services {
		res << vproto.pack_bool_field(o.cc_generic_services, 16)
	}
	if o.has_java_generic_services {
		res << vproto.pack_bool_field(o.java_generic_services, 17)
	}
	if o.has_py_generic_services {
		res << vproto.pack_bool_field(o.py_generic_services, 18)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn fileoptions_unpack(buf []byte) ?FileOptions {
	mut res := FileOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_java_package = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.java_package = v
				i = ii
			}
			8 {
				res.has_java_outer_classname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.java_outer_classname = v
				i = ii
			}
			10 {
				res.has_java_multiple_files = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.java_multiple_files = v
				i = ii
			}
			20 {
				res.has_java_generate_equals_and_hash = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.java_generate_equals_and_hash = v
				i = ii
			}
			9 {
				res.has_optimize_for = true
				ii, v := unpack_fileoptionsoptimizemode(cur_buf, tag_wiretype.wire_type)
				res.optimize_for = v
				i = ii
			}
			16 {
				res.has_cc_generic_services = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.cc_generic_services = v
				i = ii
			}
			17 {
				res.has_java_generic_services = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.java_generic_services = v
				i = ii
			}
			18 {
				res.has_py_generic_services = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.py_generic_services = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_fileoptions(o FileOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_fileoptions(buf []byte, tag_wiretype vproto.WireType) (int, FileOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := fileoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct MessageOptions {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	message_set_wire_format             bool
	has_message_set_wire_format         bool
	no_standard_descriptor_accessor     bool
	has_no_standard_descriptor_accessor bool
	uninterpreted_option                []UninterpretedOption
}

pub fn new_messageoptions() MessageOptions {
	return MessageOptions{}
}

pub fn (o &MessageOptions) pack() []byte {
	mut res := []byte{}
	if o.has_message_set_wire_format {
		res << vproto.pack_bool_field(o.message_set_wire_format, 1)
	}
	if o.has_no_standard_descriptor_accessor {
		res << vproto.pack_bool_field(o.no_standard_descriptor_accessor, 2)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn messageoptions_unpack(buf []byte) ?MessageOptions {
	mut res := MessageOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_message_set_wire_format = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.message_set_wire_format = v
				i = ii
			}
			2 {
				res.has_no_standard_descriptor_accessor = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.no_standard_descriptor_accessor = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_messageoptions(o MessageOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_messageoptions(buf []byte, tag_wiretype vproto.WireType) (int, MessageOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := messageoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

enum FieldOptionsCType {
	string = 0
	cord = 1
	string_piece = 2
}

fn pack_fieldoptionsctype(e FieldOptionsCType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

fn unpack_fieldoptionsctype(buf []byte, tag_wiretype vproto.WireType) (int, FieldOptionsCType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)
	return i, FieldOptionsCType(v)
}

pub struct FieldOptions {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	ctype                    FieldOptionsCType
	has_ctype                bool
	packed                   bool
	has_packed               bool
	deprecated               bool
	has_deprecated           bool
	experimental_map_key     string
	has_experimental_map_key bool
	uninterpreted_option     []UninterpretedOption
}

pub fn new_fieldoptions() FieldOptions {
	return FieldOptions{}
}

pub fn (o &FieldOptions) pack() []byte {
	mut res := []byte{}
	if o.has_ctype {
		res << pack_fieldoptionsctype(o.ctype, 1)
	}
	if o.has_packed {
		res << vproto.pack_bool_field(o.packed, 2)
	}
	if o.has_deprecated {
		res << vproto.pack_bool_field(o.deprecated, 3)
	}
	if o.has_experimental_map_key {
		res << vproto.pack_string_field(o.experimental_map_key, 9)
	}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn fieldoptions_unpack(buf []byte) ?FieldOptions {
	mut res := FieldOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ctype = true
				ii, v := unpack_fieldoptionsctype(cur_buf, tag_wiretype.wire_type)
				res.ctype = v
				i = ii
			}
			2 {
				res.has_packed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.packed = v
				i = ii
			}
			3 {
				res.has_deprecated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.deprecated = v
				i = ii
			}
			9 {
				res.has_experimental_map_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.experimental_map_key = v
				i = ii
			}
			999 {
				// [packed=false]
				ii, v := unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_fieldoptions(o FieldOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_fieldoptions(buf []byte, tag_wiretype vproto.WireType) (int, FieldOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := fieldoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct EnumOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	uninterpreted_option []UninterpretedOption
}

pub fn new_enumoptions() EnumOptions {
	return EnumOptions{}
}

pub fn (o &EnumOptions) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn enumoptions_unpack(buf []byte) ?EnumOptions {
	mut res := EnumOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			999 {
				// [packed=false]
				ii, v := unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_enumoptions(o EnumOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_enumoptions(buf []byte, tag_wiretype vproto.WireType) (int, EnumOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := enumoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct EnumValueOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	uninterpreted_option []UninterpretedOption
}

pub fn new_enumvalueoptions() EnumValueOptions {
	return EnumValueOptions{}
}

pub fn (o &EnumValueOptions) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn enumvalueoptions_unpack(buf []byte) ?EnumValueOptions {
	mut res := EnumValueOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			999 {
				// [packed=false]
				ii, v := unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_enumvalueoptions(o EnumValueOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_enumvalueoptions(buf []byte, tag_wiretype vproto.WireType) (int, EnumValueOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := enumvalueoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct ServiceOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	uninterpreted_option []UninterpretedOption
}

pub fn new_serviceoptions() ServiceOptions {
	return ServiceOptions{}
}

pub fn (o &ServiceOptions) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn serviceoptions_unpack(buf []byte) ?ServiceOptions {
	mut res := ServiceOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			999 {
				// [packed=false]
				ii, v := unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_serviceoptions(o ServiceOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_serviceoptions(buf []byte, tag_wiretype vproto.WireType) (int, ServiceOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := serviceoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct MethodOptions {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	uninterpreted_option []UninterpretedOption
}

pub fn new_methodoptions() MethodOptions {
	return MethodOptions{}
}

pub fn (o &MethodOptions) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.uninterpreted_option {
		res << pack_uninterpretedoption(x, 999)
	}
	return res
}

pub fn methodoptions_unpack(buf []byte) ?MethodOptions {
	mut res := MethodOptions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			999 {
				// [packed=false]
				ii, v := unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)
				res.uninterpreted_option << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_methodoptions(o MethodOptions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_methodoptions(buf []byte, tag_wiretype vproto.WireType) (int, MethodOptions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := methodoptions_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct UninterpretedOptionNamePart {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name_part      string
	is_extension   bool
}

pub fn new_uninterpretedoptionnamepart() UninterpretedOptionNamePart {
	return UninterpretedOptionNamePart{}
}

pub fn (o &UninterpretedOptionNamePart) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_string_field(o.name_part, 1)
	res << vproto.pack_bool_field(o.is_extension, 2)
	return res
}

pub fn uninterpretedoptionnamepart_unpack(buf []byte) ?UninterpretedOptionNamePart {
	mut res := UninterpretedOptionNamePart{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.name_part = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)
				res.is_extension = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_uninterpretedoptionnamepart(o UninterpretedOptionNamePart, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_uninterpretedoptionnamepart(buf []byte, tag_wiretype vproto.WireType) (int, UninterpretedOptionNamePart) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := uninterpretedoptionnamepart_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct UninterpretedOption {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	name                   []UninterpretedOptionNamePart
	identifier_value       string
	has_identifier_value   bool
	positive_int_value     u64
	has_positive_int_value bool
	negative_int_value     i64
	has_negative_int_value bool
	double_value           f64
	has_double_value       bool
	string_value           []byte
	has_string_value       bool
	aggregate_value        string
	has_aggregate_value    bool
}

pub fn new_uninterpretedoption() UninterpretedOption {
	return UninterpretedOption{}
}

pub fn (o &UninterpretedOption) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.name {
		res << pack_uninterpretedoptionnamepart(x, 2)
	}
	if o.has_identifier_value {
		res << vproto.pack_string_field(o.identifier_value, 3)
	}
	if o.has_positive_int_value {
		res << vproto.pack_uint64_field(o.positive_int_value, 4)
	}
	if o.has_negative_int_value {
		res << vproto.pack_int64_field(o.negative_int_value, 5)
	}
	if o.has_double_value {
		res << vproto.pack_double_field(o.double_value, 6)
	}
	if o.has_string_value {
		res << vproto.pack_bytes_field(o.string_value, 7)
	}
	if o.has_aggregate_value {
		res << vproto.pack_string_field(o.aggregate_value, 8)
	}
	return res
}

pub fn uninterpretedoption_unpack(buf []byte) ?UninterpretedOption {
	mut res := UninterpretedOption{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				// [packed=false]
				ii, v := unpack_uninterpretedoptionnamepart(cur_buf, tag_wiretype.wire_type)
				res.name << v
				i = ii
			}
			3 {
				res.has_identifier_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.identifier_value = v
				i = ii
			}
			4 {
				res.has_positive_int_value = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)
				res.positive_int_value = v
				i = ii
			}
			5 {
				res.has_negative_int_value = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)
				res.negative_int_value = v
				i = ii
			}
			6 {
				res.has_double_value = true
				ii, v := vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)
				res.double_value = v
				i = ii
			}
			7 {
				res.has_string_value = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)
				res.string_value = v
				i = ii
			}
			8 {
				res.has_aggregate_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)
				res.aggregate_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_uninterpretedoption(o UninterpretedOption, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_uninterpretedoption(buf []byte, tag_wiretype vproto.WireType) (int, UninterpretedOption) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := uninterpretedoption_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct SourceCodeInfoLocation {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	path           []int
	span           []int
}

pub fn new_sourcecodeinfolocation() SourceCodeInfoLocation {
	return SourceCodeInfoLocation{}
}

pub fn (o &SourceCodeInfoLocation) pack() []byte {
	mut res := []byte{}
	// [packed=true]
	res << vproto.pack_int32_field_packed(o.path, 1)
	// [packed=true]
	res << vproto.pack_int32_field_packed(o.span, 2)
	return res
}

pub fn sourcecodeinfolocation_unpack(buf []byte) ?SourceCodeInfoLocation {
	mut res := SourceCodeInfoLocation{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=true]
				ii, v := vproto.unpack_int32_field_packed(cur_buf, tag_wiretype.wire_type)
				res.path << v
				i = ii
			}
			2 {
				// [packed=true]
				ii, v := vproto.unpack_int32_field_packed(cur_buf, tag_wiretype.wire_type)
				res.span << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_sourcecodeinfolocation(o SourceCodeInfoLocation, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_sourcecodeinfolocation(buf []byte, tag_wiretype vproto.WireType) (int, SourceCodeInfoLocation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := sourcecodeinfolocation_unpack(v) or {
		panic('')
	}
	return i, unpacked
}

pub struct SourceCodeInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	location       []SourceCodeInfoLocation
}

pub fn new_sourcecodeinfo() SourceCodeInfo {
	return SourceCodeInfo{}
}

pub fn (o &SourceCodeInfo) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.location {
		res << pack_sourcecodeinfolocation(x, 1)
	}
	return res
}

pub fn sourcecodeinfo_unpack(buf []byte) ?SourceCodeInfo {
	mut res := SourceCodeInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := unpack_sourcecodeinfolocation(cur_buf, tag_wiretype.wire_type)
				res.location << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

pub fn pack_sourcecodeinfo(o SourceCodeInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

pub fn unpack_sourcecodeinfo(buf []byte, tag_wiretype vproto.WireType) (int, SourceCodeInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)
	unpacked := sourcecodeinfo_unpack(v) or {
		panic('')
	}
	return i, unpacked
}
